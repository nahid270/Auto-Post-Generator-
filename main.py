# -*- coding: utf-8 -*-

# ---- Core Python Imports ----
import os
import io
import re
import requests
import random
from threading import Thread
import logging

# --- Third-party Library Imports ---
from PIL import Image, ImageDraw, ImageFont
from pyrogram import Client, filters, enums
from pyrogram.types import InlineKeyboardMarkup, InlineKeyboardButton, Message, CallbackQuery
from pyrogram.errors import UserNotParticipant
from flask import Flask
from dotenv import load_dotenv
import motor.motor_asyncio # тЬи MongoDB-рж░ ржЬржирзНржп

# ---- 1. CONFIGURATION AND SETUP ----
load_dotenv()
BOT_TOKEN = os.getenv("BOT_TOKEN")
API_ID = int(os.getenv("API_ID"))
API_HASH = os.getenv("API_HASH")
TMDB_API_KEY = os.getenv("TMDB_API_KEY")
FORCE_SUB_CHANNEL = os.getenv("FORCE_SUB_CHANNEL")
INVITE_LINK = os.getenv("INVITE_LINK")
JOIN_CHANNEL_TEXT = "ЁЯОм рж╕ржХрж▓ ржорзБржнрж┐ ржПржмржВ рж╕рж┐рж░рж┐ржЬрзЗрж░ ржЖржкржбрзЗржЯ ржкрзЗрждрзЗ"
JOIN_CHANNEL_LINK = "https://t.me/+60goZWp-FpkxNzVl" # ржЖржкржирж╛рж░ ржЪрзНржпрж╛ржирзЗрж▓рзЗрж░ рж▓рж┐ржВржХ ржжрж┐ржи

# тнРя╕П NEW: Setup basic logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# ---- тЬи MongoDB Database Setup тЬи ----
DB_URI = os.getenv("DATABASE_URI")
DB_NAME = os.getenv("DATABASE_NAME", "MovieBotDB")
if not DB_URI:
    logger.critical("CRITICAL: DATABASE_URI is not set. Bot cannot start without a database.")
    exit()
db_client = motor.motor_asyncio.AsyncIOMotorClient(DB_URI)
db = db_client[DB_NAME]
users_collection = db.users

# ---- Global Variables & Bot Initialization ----
user_conversations = {}
bot = Client("UltimateMovieBot", api_id=API_ID, api_hash=API_HASH, bot_token=BOT_TOKEN)

# ---- Flask App (for Keep-Alive) ----
app = Flask(__name__)
@app.route('/')
def home(): return "тЬЕ Bot is Running!"
Thread(target=lambda: app.run(host='0.0.0.0', port=int(os.environ.get('PORT', 8080))), daemon=True).start()

# ---- 2. DECORATORS AND HELPER FUNCTIONS ----
async def add_user_to_db(user):
    # ЁЯФД MODIFIED: Store user's first name for better interaction
    await users_collection.update_one(
        {'_id': user.id},
        {'$set': {'first_name': user.first_name}},
        upsert=True
    )

def force_subscribe(func):
    async def wrapper(client, message):
        if FORCE_SUB_CHANNEL:
            try:
                chat_id = int(FORCE_SUB_CHANNEL) if FORCE_SUB_CHANNEL.startswith("-100") else FORCE_SUB_CHANNEL
                await client.get_chat_member(chat_id, message.from_user.id)
            except UserNotParticipant:
                join_link = INVITE_LINK or f"https://t.me/{FORCE_SUB_CHANNEL.replace('@', '')}"
                return await message.reply_text("тЭЧ **ржПржЗ ржмржЯ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рждрзЗ ржЖржорж╛ржжрзЗрж░ ржЪрзНржпрж╛ржирзЗрж▓рзЗ ржпрзЛржЧ ржжрж┐ржиред**", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("ЁЯСЙ ржЪрзНржпрж╛ржирзЗрж▓рзЗ ржпрзЛржЧ ржжрж┐ржи", url=join_link)]]))
        await func(client, message)
    return wrapper

# тнРя╕П NEW: Link Shortener Function
async def shorten_link(user_id: int, long_url: str):
    """Shortens a URL using the user's saved shortener settings."""
    user_data = await users_collection.find_one({'_id': user_id})
    if not user_data or 'shortener_api' not in user_data or 'shortener_url' not in user_data:
        return long_url # Return original URL if no shortener is configured

    api_key = user_data['shortener_api']
    base_url = user_data['shortener_url']
    
    # Construct the API URL. This format is common for many shorteners (e.g., Zagl, ShrinkEarn).
    api_url = f"https://{base_url}/api?api={api_key}&url={long_url}"
    
    try:
        response = requests.get(api_url, timeout=10)
        response.raise_for_status()
        data = response.json()
        if data.get("status") == "success" and data.get("shortenedUrl"):
            logger.info(f"Successfully shortened URL for user {user_id}")
            return data["shortenedUrl"]
        else:
            logger.warning(f"Shortener API returned an error for user {user_id}: {data.get('message', 'Unknown error')}")
            return long_url # Return original on API error
    except requests.exceptions.RequestException as e:
        logger.error(f"Failed to call shortener API for user {user_id}. Error: {e}")
        return long_url # Return original on network error

def format_runtime(minutes: int):
    if not minutes or not isinstance(minutes, int): return "N/A"
    hours, mins = divmod(minutes, 60)
    return f"{hours}h {mins}m" if hours > 0 else f"{mins}m"

# ---- 3. TMDB API & CONTENT GENERATION ----
def search_tmdb(query: str):
    year, name = None, query.strip()
    match = re.search(r'(.+?)\s*\(?(\d{4})\)?$', query)
    if match: name, year = match.group(1).strip(), match.group(2)
    url = f"https://api.themoviedb.org/3/search/multi?api_key={TMDB_API_KEY}&query={name}" + (f"&year={year}" if year else "")
    try:
        r = requests.get(url, timeout=10); r.raise_for_status()
        return [res for res in r.json().get("results", []) if res.get("media_type") in ["movie", "tv"]][:5]
    except Exception as e:
        logger.error(f"TMDB Search Error: {e}"); return []

def get_tmdb_details(media_type: str, media_id: int):
    url = f"https://api.themoviedb.org/3/{media_type}/{media_id}?api_key={TMDB_API_KEY}&append_to_response=credits"
    try:
        r = requests.get(url, timeout=10); r.raise_for_status(); return r.json()
    except Exception as e:
        logger.error(f"TMDB Details Error: {e}"); return None

def watermark_poster(poster_url: str, watermark_text: str):
    if not poster_url: return None, "Poster URL not found."
    try:
        img_data = requests.get(poster_url, timeout=20).content
        img = Image.open(io.BytesIO(img_data)).convert("RGBA")
        if watermark_text:
            draw = ImageDraw.Draw(img)
            font_size = int(img.width / 12)
            try:
                font = ImageFont.truetype("Poppins-Bold.ttf", font_size)
            except IOError:
                logger.warning("Poppins-Bold.ttf not found. Using default font.")
                font = ImageFont.load_default()
            
            thumbnail = img.resize((150, 150))
            colors = thumbnail.getcolors(150*150)
            text_color = (255, 255, 255, 230)
            if colors:
                dominant_color = sorted(colors, key=lambda x: x[0], reverse=True)[0][1]
                text_color = (255 - dominant_color[0], 255 - dominant_color[1], 255 - dominant_color[2], 230)

            bbox = draw.textbbox((0, 0), watermark_text, font=font)
            text_width, text_height = bbox[2] - bbox[0], bbox[3] - bbox[1]
            x = (img.width - text_width) / 2
            y = img.height - text_height - (img.height * 0.05)
            draw.text((x + 2, y + 2), watermark_text, font=font, fill=(0, 0, 0, 128))
            draw.text((x, y), watermark_text, font=font, fill=text_color)
            
        buffer = io.BytesIO(); buffer.name = "poster.png"
        img.save(buffer, "PNG"); buffer.seek(0)
        return buffer, None
    except requests.exceptions.RequestException as e: return None, f"Network Error: {e}"
    except Exception as e: return None, f"Image processing error. Error: {e}"

async def generate_channel_caption(data: dict, language: str, links: dict, user_data: dict):
    title = data.get("title") or data.get("name") or "N/A"
    year = (data.get("release_date") or data.get("first_air_date") or "----")[:4]
    genres = ", ".join([g["name"] for g in data.get("genres", [])[:3]]) or "N/A"
    rating = f"{data.get('vote_average', 0):.1f}/10"
    overview = data.get("overview", "ржХрж╛рж╣рж┐ржирзА рж╕ржВржХрзНрж╖рзЗржк ржкрж╛ржУрзЯрж╛ ржпрж╛рзЯржирж┐ред")
    if len(overview) > 250: overview = overview[:250] + "..."
    cast = ", ".join([a['name'] for a in data.get('credits', {}).get('cast', [])[:3]]) or "N/A"
    
    caption_header = (f"тнРя╕П **рж░рзЗржЯрж┐ржВ:** {rating}\nЁЯОн **ржзрж░ржи:** {genres}\n"
                      f"ЁЯФК **ржнрж╛рж╖рж╛:** {language}\n")

    if 'first_air_date' in data: # TV Show
        runtime_list = data.get("episode_run_time", [])
        runtime = format_runtime(runtime_list[0] if runtime_list else 0)
        seasons = data.get("number_of_seasons", "N/A")
        caption_header = (f"ЁЯУ║ **{title} ({year})**\n\n" + caption_header +
                          f"ЁЯУК **ржорзЛржЯ рж╕рж┐ржЬржи:** {seasons}\n"
                          f"тП░ **ржкрзНрж░рждрж┐ ржкрж░рзНржмрзЗрж░ рж░рж╛ржиржЯрж╛ржЗржо:** {runtime}\n"
                          f"ЁЯСе **ржЕржнрж┐ржирзЯрзЗ:** {cast}\n\nЁЯУЭ **ржХрж╛рж╣рж┐ржирзА рж╕ржВржХрзНрж╖рзЗржк:** {overview}\n\n")
        
        link_section = "тЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦм\nЁЯУе **ржбрж╛ржЙржирж▓рзЛржб рж▓рж┐ржВржХрж╕ржорзВрж╣** ЁЯУе\nтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦм\n"
        if links:
            sorted_seasons = sorted(links.keys(), key=int)
            for season_num in sorted_seasons:
                link_section += f"тЬЕ **[рж╕рж┐ржЬржи {season_num} ржбрж╛ржЙржирж▓рзЛржб ржХрж░рзБржи]({links[season_num]})**\n"
    else: # Movie
        runtime = format_runtime(data.get("runtime", 0))
        caption_header = (f"ЁЯОм **{title} ({year})**\n\n" + caption_header +
                          f"тП░ **рж░рж╛ржиржЯрж╛ржЗржо:** {runtime}\n"
                          f"ЁЯСе **ржЕржнрж┐ржирзЯрзЗ:** {cast}\n\nЁЯУЭ **ржХрж╛рж╣рж┐ржирзА рж╕ржВржХрзНрж╖рзЗржк:** {overview}\n\n")
        
        link_section = "тЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦм\nЁЯУе **ржбрж╛ржЙржирж▓рзЛржб рж▓рж┐ржВржХрж╕ржорзВрж╣** ЁЯУе\nтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦмтЦм\n"
        if links.get("480p"): link_section += f"тЬЕ **[480p ржХрзЛрзЯрж╛рж▓рж┐ржЯрж┐ ржбрж╛ржЙржирж▓рзЛржб]({links['480p']})**\n"
        if links.get("720p"): link_section += f"тЬЕ **[720p ржХрзЛрзЯрж╛рж▓рж┐ржЯрж┐ ржбрж╛ржЙржирж▓рзЛржб]({links['720p']})**\n"
        if links.get("1080p"): link_section += f"тЬЕ **[1080p ржХрзЛрзЯрж╛рж▓рж┐ржЯрж┐ ржбрж╛ржЙржирж▓рзЛржб]({links['1080p']})**\n"

    caption = caption_header + link_section

    if user_data and user_data.get('tutorial_link'):
        caption += f"\nЁЯОе **ржХрж┐ржнрж╛ржмрзЗ ржбрж╛ржЙржирж▓рзЛржб ржХрж░ржмрзЗржи:** [ржЯрж┐ржЙржЯрзЛрж░рж┐рзЯрж╛рж▓ ржжрзЗржЦрзБржи]({user_data['tutorial_link']})"

    if JOIN_CHANNEL_TEXT and JOIN_CHANNEL_LINK:
        caption += f"\n---\n**ржЖржорж╛ржжрзЗрж░ ржЕржирзНржп ржЪрзНржпрж╛ржирзЗрж▓рзЗ ржпрзЛржЧ ржжрж┐ржи ЁЯСЗ**\n[ЁЯСЙ {JOIN_CHANNEL_TEXT}]({JOIN_CHANNEL_LINK})"
    return caption

# ---- 4. BOT HANDLERS ----
@bot.on_message(filters.command("start") & filters.private)
@force_subscribe
async def start_cmd(client, message: Message):
    await add_user_to_db(message.from_user)
    await message.reply_text(f"ЁЯСЛ **рж╕рзНржмрж╛ржЧрждржо, {message.from_user.first_name}! ржЖржорж┐ ржорзБржнрж┐ ржУ рж╕рж┐рж░рж┐ржЬ ржкрзЛрж╕рзНржЯ ржЬрзЗржирж╛рж░рзЗржЯрж░ ржмржЯред**\n\n"
        "**ржЖржорж╛рж░ ржХржорж╛ржирзНржбржЧрзБрж▓рзЛ рж╣рж▓рзЛ:**\n"
        "ЁЯФ╣ `/post <name>` - ржорзБржнрж┐ ржмрж╛ рж╕рж┐рж░рж┐ржЬрзЗрж░ ржЬржирзНржп ржкрзЛрж╕рзНржЯ рждрзИрж░рж┐ ржХрж░рзБржиред\n"
        "ЁЯФ╣ `/cancel` - ржпрзЗржХрзЛржирзЛ ржЪрж▓ржорж╛ржи ржкрзНрж░ржХрзНрж░рж┐рзЯрж╛ ржмрж╛рждрж┐рж▓ ржХрж░рзБржиред\n\n"
        "**рж╕рзЗржЯрж┐ржВрж╕:**\n"
        "ЁЯФ╣ `/settings` - ржЖржкржирж╛рж░ ржмрж░рзНрждржорж╛ржи рж╕рзЗржЯрж┐ржВрж╕ ржжрзЗржЦрзБржиред\n"
        "ЁЯФ╣ `/setchannel <ID>` - ржкрзЛрж╕рзНржЯ ржХрж░рж╛рж░ ржЬржирзНржп ржЪрзНржпрж╛ржирзЗрж▓ ржЖржЗржбрж┐ рж╕рзЗржЯ ржХрж░рзБржиред\n"
        "ЁЯФ╣ `/setwatermark <text>` - ржкрзЛрж╕рзНржЯрж╛рж░рзЗ ржУрзЯрж╛ржЯрж╛рж░ржорж╛рж░рзНржХ рж╕рзЗржЯ ржХрж░рзБржиред\n"
        "ЁЯФ╣ `/setapi <API_KEY>` - ржЖржкржирж╛рж░ рж▓рж┐ржЩрзНржХ рж╢рж░рзНржЯржирж╛рж░рзЗрж░ API Key рж╕рзЗржЯ ржХрж░рзБржиред\n"
        "ЁЯФ╣ `/setdomain <URL>` - ржЖржкржирж╛рж░ рж╢рж░рзНржЯржирж╛рж░ ржбрзЛржорзЗржЗржи рж╕рзЗржЯ ржХрж░рзБржи (e.g., yoursite.com)ред\n"
        "ЁЯФ╣ `/settutorial <link>` - ржбрж╛ржЙржирж▓рзЛржб ржЯрж┐ржЙржЯрзЛрж░рж┐рзЯрж╛рж▓ рж▓рж┐ржЩрзНржХ рж╕рзЗржЯ ржХрж░рзБржиред")

# ЁЯФД ржкрж░рж┐ржмрж░рзНрждржи: рж▓рж┐ржЩрзНржХ рж╢рж░рзНржЯржирж╛рж░ ржХржорж╛ржирзНржбржЧрзБрж▓рзЛ ржЖрж▓рж╛ржжрж╛ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ ржПржмржВ settings ржХржорж╛ржирзНржбрзЗрж░ рж╕рж╛ржерзЗ ржпрзБржХрзНржд ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗред
@bot.on_message(filters.command(["setwatermark", "setchannel", "cancel", "setapi", "setdomain", "settutorial", "settings"]) & filters.private)
@force_subscribe
async def settings_commands(client, message: Message):
    command = message.command[0].lower()
    uid = message.from_user.id
    await add_user_to_db(message.from_user)

    if command == "setwatermark":
        text = " ".join(message.command[1:]) if len(message.command) > 1 else None
        await users_collection.update_one({'_id': uid}, {'$set': {'watermark_text': text}}, upsert=True)
        await message.reply_text(f"тЬЕ ржУрзЯрж╛ржЯрж╛рж░ржорж╛рж░рзНржХ {'рж╕рзЗржЯ рж╣рзЯрзЗржЫрзЗ: `' + text + '`' if text else 'ржорзБржЫрзЗ ржлрзЗрж▓рж╛ рж╣рзЯрзЗржЫрзЗред'}")
    
    elif command == "setchannel":
        if len(message.command) > 1 and message.command[1].startswith("-100") and message.command[1][1:].isdigit():
            cid = message.command[1]
            await users_collection.update_one({'_id': uid}, {'$set': {'channel_id': cid}}, upsert=True)
            await message.reply_text(f"тЬЕ ржЪрзНржпрж╛ржирзЗрж▓ рж╕рзЗржЯ рж╣рзЯрзЗржЫрзЗ: `{cid}`")
        else:
            await message.reply_text("тЪая╕П ржЕржмрзИржз ржЪрзНржпрж╛ржирзЗрж▓ ржЖржЗржбрж┐ред ржЖржЗржбрж┐ ржЕржмрж╢рзНржпржЗ `-100` ржжрж┐рзЯрзЗ рж╢рзБрж░рзБ рж╣рждрзЗ рж╣ржмрзЗред\n**ржмрзНржпржмрж╣рж╛рж░:** `/setchannel -100...`")
            
    elif command == "cancel":
        if uid in user_conversations:
            del user_conversations[uid]
            await message.reply_text("тЬЕ ржкрзНрж░ржХрзНрж░рж┐рзЯрж╛ ржмрж╛рждрж┐рж▓ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗред")
        else:
            await message.reply_text("ЁЯЪл ржмрж╛рждрж┐рж▓ ржХрж░рж╛рж░ ржорждрзЛ ржХрзЛржирзЛ ржкрзНрж░ржХрзНрж░рж┐рзЯрж╛ ржЪрж╛рж▓рзБ ржирзЗржЗред")

    # тнРя╕П NEW: Shortener API command handler
    elif command == "setapi":
        if len(message.command) > 1:
            api_key = message.command[1]
            await users_collection.update_one({'_id': uid}, {'$set': {'shortener_api': api_key}}, upsert=True)
            await message.reply_text(f"тЬЕ рж╢рж░рзНржЯржирж╛рж░ API Key рж╕рзЗржЯ рж╣рзЯрзЗржЫрзЗ: `{api_key}`")
        else:
            await message.reply_text("тЪая╕П ржнрзБрж▓ ржлрж░ржорзНржпрж╛ржЯ!\n**ржмрзНржпржмрж╣рж╛рж░:** `/setapi <ржЖржкржирж╛рж░_API_KEY>`")

    # тнРя╕П NEW: Shortener Domain command handler
    elif command == "setdomain":
        if len(message.command) > 1:
            domain = message.command[1]
            await users_collection.update_one({'_id': uid}, {'$set': {'shortener_url': domain}}, upsert=True)
            await message.reply_text(f"тЬЕ рж╢рж░рзНржЯржирж╛рж░ ржбрзЛржорзЗржЗржи рж╕рзЗржЯ рж╣рзЯрзЗржЫрзЗ: `{domain}`")
        else:
            await message.reply_text("тЪая╕П ржнрзБрж▓ ржлрж░ржорзНржпрж╛ржЯ!\n**ржмрзНржпржмрж╣рж╛рж░:** `/setdomain yourshortener.com` (http:// ржмрж╛ https:// ржЫрж╛рзЬрж╛)ред")

    # тнРя╕П NEW: Tutorial command handler
    elif command == "settutorial":
        if len(message.command) > 1:
            link = message.command[1]
            await users_collection.update_one({'_id': uid}, {'$set': {'tutorial_link': link}}, upsert=True)
            await message.reply_text(f"тЬЕ ржЯрж┐ржЙржЯрзЛрж░рж┐рзЯрж╛рж▓ рж▓рж┐ржЩрзНржХ рж╕рзЗржЯ рж╣рзЯрзЗржЫрзЗ: {link}")
        else:
            await users_collection.update_one({'_id': uid}, {'$unset': {'tutorial_link': ""}})
            await message.reply_text("тЬЕ ржЯрж┐ржЙржЯрзЛрж░рж┐рзЯрж╛рж▓ рж▓рж┐ржЩрзНржХ ржорзБржЫрзЗ ржлрзЗрж▓рж╛ рж╣рзЯрзЗржЫрзЗред")

    # тнРя╕П NEW: Settings view command
    elif command == "settings":
        user_data = await users_collection.find_one({'_id': uid})
        if not user_data:
            return await message.reply_text("ржЖржкржирж╛рж░ ржХрзЛржирзЛ рж╕рзЗржЯрж┐ржВрж╕ рж╕рзЗржн ржХрж░рж╛ ржирзЗржЗред")
        
        settings_text = "**тЪЩя╕П ржЖржкржирж╛рж░ ржмрж░рзНрждржорж╛ржи рж╕рзЗржЯрж┐ржВрж╕:**\n\n"
        settings_text += f"**ржЪрзНржпрж╛ржирзЗрж▓ ржЖржЗржбрж┐:** `{user_data.get('channel_id', 'рж╕рзЗржЯ ржХрж░рж╛ ржирзЗржЗ')}`\n"
        settings_text += f"**ржУрзЯрж╛ржЯрж╛рж░ржорж╛рж░рзНржХ:** `{user_data.get('watermark_text', 'рж╕рзЗржЯ ржХрж░рж╛ ржирзЗржЗ')}`\n"
        settings_text += f"**ржЯрж┐ржЙржЯрзЛрж░рж┐рзЯрж╛рж▓ рж▓рж┐ржЩрзНржХ:** `{user_data.get('tutorial_link', 'рж╕рзЗржЯ ржХрж░рж╛ ржирзЗржЗ')}`\n"
        
        shortener_api = user_data.get('shortener_api')
        shortener_url = user_data.get('shortener_url')
        if shortener_api and shortener_url:
            settings_text += f"**рж╢рж░рзНржЯржирж╛рж░ API:** `{shortener_api}`\n"
            settings_text += f"**рж╢рж░рзНржЯржирж╛рж░ URL:** `{shortener_url}`\n"
        else:
            settings_text += "**рж╢рж░рзНржЯржирж╛рж░:** `рж╕рзЗржЯ ржХрж░рж╛ ржирзЗржЗ` (API ржУ ржбрзЛржорзЗржЗржи ржжрзБржЯрзЛржЗ рж╕рзЗржЯ ржХрж░рзБржи)\n"
            
        await message.reply_text(settings_text)

async def generate_final_post_preview(client, uid, cid, msg):
    convo = user_conversations.get(uid)
    if not convo: return
    
    user_data = await users_collection.find_one({'_id': uid})
    
    caption = await generate_channel_caption(convo["details"], convo["language"], convo["links"], user_data)
    
    watermark = user_data.get('watermark_text') if user_data else None
    poster_url = f"https://image.tmdb.org/t/p/w500{convo['details']['poster_path']}" if convo['details'].get('poster_path') else None
    
    await msg.edit_text("ЁЯЦ╝я╕П ржкрзЛрж╕рзНржЯрж╛рж░ рждрзИрж░рж┐ ржПржмржВ ржУрзЯрж╛ржЯрж╛рж░ржорж╛рж░рзНржХ ржпрзЛржЧ ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ...")
    poster, error = watermark_poster(poster_url, watermark)
    
    await msg.delete()
    if error:
        await client.send_message(cid, f"тЪая╕П **ржкрзЛрж╕рзНржЯрж╛рж░ рждрзИрж░рж┐рждрзЗ рж╕ржорж╕рзНржпрж╛:** `{error}`")

    poster_buffer = None
    if poster:
        poster.seek(0)
        poster_buffer = io.BytesIO(poster.read())
        poster.seek(0)

    preview_msg = await client.send_photo(cid, photo=poster, caption=caption, parse_mode=enums.ParseMode.MARKDOWN) if poster else await client.send_message(cid, caption, parse_mode=enums.ParseMode.MARKDOWN)
    
    user_conversations[uid]['final_post'] = {'caption': caption, 'poster': poster_buffer}

    channel_id = user_data.get('channel_id') if user_data else None
    if channel_id:
        await client.send_message(cid, "**ЁЯСЖ ржПржЯрж┐ ржПржХржЯрж┐ ржкрзНрж░рж┐ржнрж┐ржЙред**\nржЖржкржирж╛рж░ ржЪрзНржпрж╛ржирзЗрж▓рзЗ ржкрзЛрж╕рзНржЯ ржХрж░ржмрзЗржи?",
            reply_to_message_id=preview_msg.id,
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("ЁЯУв рж╣рзНржпрж╛ржБ, ржЪрзНржпрж╛ржирзЗрж▓рзЗ ржкрзЛрж╕рзНржЯ ржХрж░рзБржи", callback_data=f"finalpost_{uid}")]]))

@bot.on_message(filters.command("post") & filters.private)
@force_subscribe
async def search_commands(client, message: Message):
    if len(message.command) == 1:
        return await message.reply_text("**ржмрзНржпржмрж╣рж╛рж░:** `/post Movie or Series Name`")
    query = " ".join(message.command[1:])
    processing_msg = await message.reply_text(f"ЁЯФН `{query}`-ржПрж░ ржЬржирзНржп ржЦрзЛржБржЬрж╛ рж╣ржЪрзНржЫрзЗ...")
    results = search_tmdb(query)
    if not results:
        return await processing_msg.edit_text("тЭМ ржХрзЛржирзЛ ржлрж▓рж╛ржлрж▓ ржкрж╛ржУрзЯрж╛ ржпрж╛рзЯржирж┐ред")
    buttons = []
    for r in results:
        media_icon = 'ЁЯОм' if r['media_type'] == 'movie' else 'ЁЯУ║'
        title = r.get('title') or r.get('name')
        year = (r.get('release_date') or r.get('first_air_date') or '----').split('-')[0]
        buttons.append([InlineKeyboardButton(f"{media_icon} {title} ({year})", callback_data=f"select_post_{r['media_type']}_{r['id']}")])
    await processing_msg.edit_text("**ЁЯСЗ ржлрж▓рж╛ржлрж▓ ржерзЗржХрзЗ ржмрзЗржЫрзЗ ржирж┐ржи:**", reply_markup=InlineKeyboardMarkup(buttons))

@bot.on_message(filters.text & filters.private)
@force_subscribe
async def conversation_handler(client, message: Message):
    uid, text = message.from_user.id, message.text.strip()
    convo = user_conversations.get(uid)
    if not convo or "state" not in convo: return
    
    state = convo["state"]
    processing_msg = None

    async def process_link(quality, next_state, next_prompt):
        nonlocal processing_msg
        if text.lower() != 'skip':
            processing_msg = await message.reply("ЁЯФЧ рж▓рж┐ржЩрзНржХржЯрж┐ рж╢рж░рзНржЯ ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ...", quote=True)
            shortened = await shorten_link(uid, text)
            convo["links"][quality] = shortened
        convo["state"] = next_state
        prompt = f"тЬЕ рж▓рж┐ржЩрзНржХ {'рж╢рж░рзНржЯ ржПржмржВ ржпрзЛржЧ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ' if text.lower() != 'skip' else 'рж╕рзНржХрж┐ржк ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ'}ред ржПржЦржи {next_prompt}"
        if processing_msg: await processing_msg.edit_text(prompt)
        else: await message.reply_text(prompt)

    if state == "wait_movie_lang":
        convo["language"] = text; convo["state"] = "wait_480p"
        await message.reply_text("тЬЕ ржнрж╛рж╖рж╛ рж╕рзЗржЯ рж╣рзЯрзЗржЫрзЗред ржПржЦржи **480p** рж▓рж┐ржВржХ ржкрж╛ржарж╛ржи ржЕржержмрж╛ `skip` рж▓рж┐ржЦрзБржиред")
    elif state == "wait_480p":
        await process_link("480p", "wait_720p", "**720p** рж▓рж┐ржВржХ ржкрж╛ржарж╛ржи ржЕржержмрж╛ `skip` рж▓рж┐ржЦрзБржиред")
    elif state == "wait_720p":
        await process_link("720p", "wait_1080p", "**1080p** рж▓рж┐ржВржХ ржкрж╛ржарж╛ржи ржЕржержмрж╛ `skip` рж▓рж┐ржЦрзБржиред")
    elif state == "wait_1080p":
        if text.lower() != 'skip':
            processing_msg = await message.reply("ЁЯФЧ рж▓рж┐ржЩрзНржХржЯрж┐ рж╢рж░рзНржЯ ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ...", quote=True)
            shortened = await shorten_link(uid, text)
            convo["links"]["1080p"] = shortened
        msg = await (processing_msg.edit_text if processing_msg else message.reply)("тЬЕ рждржерзНржп рж╕ржВржЧрзНрж░рж╣ рж╕ржорзНржкржирзНржи! ржкрзНрж░рж┐ржнрж┐ржЙ рждрзИрж░рж┐ ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ...")
        await generate_final_post_preview(client, uid, message.chat.id, msg)

    elif state == "wait_tv_lang":
        convo["language"] = text; convo["state"] = "wait_season_number"
        await message.reply_text("тЬЕ ржнрж╛рж╖рж╛ рж╕рзЗржЯ рж╣рзЯрзЗржЫрзЗред ржПржЦржи рж╕рж┐ржЬржирзЗрж░ ржиржорзНржмрж░ рж▓рж┐ржЦрзБржи (ржпрзЗржоржи: 1, 2)ред")
    elif state == "wait_season_number":
        if text.lower() == 'done':
            if not convo.get('seasons'): return await message.reply_text("тЪая╕П ржЖржкржирж┐ ржХрзЛржирзЛ рж╕рж┐ржЬржирзЗрж░ рж▓рж┐ржВржХ ржпрзЛржЧ ржХрж░рзЗржиржирж┐ред")
            msg = await message.reply_text("тЬЕ рж╕ржХрж▓ рж╕рж┐ржЬржирзЗрж░ рждржерзНржп рж╕ржВржЧрзНрж░рж╣ рж╕ржорзНржкржирзНржи! ржкрзНрж░рж┐ржнрж┐ржЙ рждрзИрж░рж┐ ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ...", quote=True)
            convo['links'] = convo['seasons']
            await generate_final_post_preview(client, uid, message.chat.id, msg)
            return
        if not text.isdigit() or int(text) <= 0: return await message.reply_text("тЭМ ржнрзБрж▓ ржиржорзНржмрж░ред ржжрзЯрж╛ ржХрж░рзЗ ржПржХржЯрж┐ рж╕ржарж┐ржХ рж╕рж┐ржЬржи ржиржорзНржмрж░ ржжрж┐ржиред")
        convo['current_season'] = text
        convo['state'] = 'wait_season_link'
        await message.reply_text(f"ЁЯСН ржарж┐ржХ ржЖржЫрзЗред ржПржЦржи **рж╕рж┐ржЬржи {text}**-ржПрж░ ржбрж╛ржЙржирж▓рзЛржб рж▓рж┐ржВржХ ржкрж╛ржарж╛ржиред")
    elif state == "wait_season_link":
        season_num = convo.get('current_season')
        processing_msg = await message.reply("ЁЯФЧ рж▓рж┐ржЩрзНржХржЯрж┐ рж╢рж░рзНржЯ ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ...", quote=True)
        shortened = await shorten_link(uid, text)
        convo['seasons'][season_num] = shortened
        convo['state'] = 'wait_season_number'
        await processing_msg.edit_text(f"тЬЕ рж╕рж┐ржЬржи {season_num}-ржПрж░ рж▓рж┐ржВржХ ржпрзЛржЧ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗред\n\n**ЁЯСЙ ржкрж░ржмрж░рзНрждрзА рж╕рж┐ржЬржирзЗрж░ ржиржорзНржмрж░ рж▓рж┐ржЦрзБржи, ржЕржержмрж╛ ржкрзЛрж╕рзНржЯ рж╢рзЗрж╖ ржХрж░рждрзЗ `done` рж▓рж┐ржЦрзБржиред**")

@bot.on_callback_query(filters.regex("^select_"))
async def selection_cb(client, cb: CallbackQuery):
    await cb.answer("Fetching details...", show_alert=False)
    try: _, flow, media_type, mid = cb.data.split("_", 3)
    except Exception as e:
        logger.error(f"Callback Error on split: {e}")
        return await cb.message.edit_text("Invalid callback data.")
        
    details = get_tmdb_details(media_type, int(mid))
    if not details: return await cb.message.edit_text("тЭМ ржжрзБржГржЦрж┐ржд, TMDB ржерзЗржХрзЗ ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд рждржерзНржп ржЖржирждрзЗ ржкрж╛рж░рж┐ржирж┐ред")
    
    uid = cb.from_user.id
    user_conversations[uid] = {"flow": flow, "details": details, "links": {}, "state": ""}
    
    if media_type == "tv":
        user_conversations[uid]["state"] = "wait_tv_lang"
        user_conversations[uid]['seasons'] = {}
        await cb.message.edit_text("**ржУрзЯрзЗржм рж╕рж┐рж░рж┐ржЬ ржкрзЛрж╕рзНржЯ:** рж╕рж┐рж░рж┐ржЬржЯрж┐рж░ ржЬржирзНржп ржнрж╛рж╖рж╛ рж▓рж┐ржЦрзБржи (ржпрзЗржоржи: ржмрж╛ржВрж▓рж╛, ржЗржВрж░рзЗржЬрж┐)ред")
    elif media_type == "movie":
        user_conversations[uid]["state"] = "wait_movie_lang"
        await cb.message.edit_text("**ржорзБржнрж┐ ржкрзЛрж╕рзНржЯ:** ржорзБржнрж┐ржЯрж┐рж░ ржЬржирзНржп ржнрж╛рж╖рж╛ рж▓рж┐ржЦрзБржиред")

@bot.on_callback_query(filters.regex("^finalpost_"))
async def post_to_channel_cb(client, cb: CallbackQuery):
    uid = cb.from_user.id
    user_data = await users_collection.find_one({'_id': uid})
    channel_id = user_data.get('channel_id') if user_data else None

    if not channel_id:
        await cb.answer("тЪая╕П ржЪрзНржпрж╛ржирзЗрж▓ рж╕рзЗржЯ ржХрж░рж╛ ржирзЗржЗ!", show_alert=True)
        return await cb.message.edit_text("ржЖржкржирж┐ ржПржЦржиржУ ржХрзЛржирзЛ ржЪрзНржпрж╛ржирзЗрж▓ рж╕рзЗржЯ ржХрж░рзЗржиржирж┐ред `/setchannel <ID>` ржХржорж╛ржирзНржб ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржиред")

    convo = user_conversations.get(uid)
    if not convo or 'final_post' not in convo:
        await cb.answer("тЭМ рж╕рзЗрж╢ржи рж╢рзЗрж╖ рж╣рзЯрзЗ ржЧрзЗржЫрзЗ!", show_alert=True)
        return await cb.message.edit_text("ржжрзБржГржЦрж┐ржд, ржПржЗ ржкрзЛрж╕рзНржЯрзЗрж░ рждржерзНржп ржЖрж░ ржкрж╛ржУрзЯрж╛ ржпрж╛ржЪрзНржЫрзЗ ржирж╛ред ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржЖржмрж╛рж░ рж╢рзБрж░рзБ ржХрж░рзБржиред")

    await cb.answer("тП│ ржкрзЛрж╕рзНржЯ ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ...", show_alert=False)
    
    final_post = convo['final_post']
    caption = final_post['caption']
    poster = final_post['poster']

    try:
        if poster:
            poster.seek(0)
            await client.send_photo(chat_id=int(channel_id), photo=poster, caption=caption, parse_mode=enums.ParseMode.MARKDOWN)
        else:
            await client.send_message(chat_id=int(channel_id), text=caption, parse_mode=enums.ParseMode.MARKDOWN)
        
        await cb.message.edit_text("тЬЕ **рж╕ржлрж▓ржнрж╛ржмрзЗ ржЖржкржирж╛рж░ ржЪрзНржпрж╛ржирзЗрж▓рзЗ ржкрзЛрж╕рзНржЯ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ!**")
    except Exception as e:
        logger.error(f"Failed to post to channel {channel_id} for user {uid}. Error: {e}")
        error_message = (f"тЭМ **ржЪрзНржпрж╛ржирзЗрж▓рзЗ ржкрзЛрж╕рзНржЯ ржХрж░рждрзЗ рж╕ржорж╕рзНржпрж╛ рж╣рзЯрзЗржЫрзЗред**\n\n"
                         f"**рж╕ржорзНржнрж╛ржмрзНржп ржХрж╛рж░ржг:**\n"
                         f"1. ржмржЯ ржХрж┐ ржЖржкржирж╛рж░ ржЪрзНржпрж╛ржирзЗрж▓рзЗрж░ (`{channel_id}`) рж╕ржжрж╕рзНржп?\n"
                         f"2. ржмржЯрзЗрж░ ржХрж┐ 'Post Messages' ржХрж░рж╛рж░ ржЕржирзБржорждрж┐ ржЖржЫрзЗ?\n"
                         f"3. ржЪрзНржпрж╛ржирзЗрж▓ ржЖржЗржбрж┐ ржХрж┐ рж╕ржарж┐ржХ?\n\n"
                         f"**Error:** `{e}`")
        await cb.message.edit_text(error_message)
    finally:
        if uid in user_conversations:
            del user_conversations[uid]

# ---- 5. START THE BOT ----
if __name__ == "__main__":
    logger.info("ЁЯЪА Bot is starting with MongoDB connection...")
    bot.run()
    logger.info("ЁЯСЛ Bot has stopped.")
